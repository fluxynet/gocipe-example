// generated by gocipe 98bee01dcbcfef2fa8be1efb59ffb2d095d1ca8b8d0200a0c99f31ad111a69db; DO NOT EDIT

package citizen

import (
	"context"
	"database/sql"
	"strconv"
	"strings"

	"github.com/fluxynet/gocipe-example/models"
	"github.com/gobuffalo/uuid"
)

var db *sql.DB

// Inject allows injection of services into the package
func Inject(database *sql.DB) {
	db = database
}

// Get returns a single Citizen from database by primary key
func Get(ctx context.Context, id string) (*Citizen, error) {
	var (
		rows   *sql.Rows
		err    error
		entity = New()
	)

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	default:
		break
	}

	rows, err = db.Query("SELECT id, surname, othernames, gender, dob FROM  WHERE id = $1 ORDER BY .id ASC", id)
	if err != nil {
		return nil, err
	}

	defer rows.Close()
	if rows.Next() {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
			err = rows.Scan(entity.ID, entity.Surname, entity.OtherNames, entity.Gender, entity.DOB)
			if err != nil {
				return nil, err
			}
		}
	}

	return entity, nil
}

// List returns a slice containing Citizen records
func List(ctx context.Context, filters []models.ListFilter) ([]*Citizen, error) {
	var (
		list     []*Citizen
		segments []string
		values   []interface{}
		err      error
		rows     *sql.Rows
	)

	query := "SELECT id, surname, othernames, gender, dob FROM "

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	default:
		break
	}

	for i, filter := range filters {
		segments = append(segments, filter.Field+" "+filter.Operation+" $"+strconv.Itoa(i+1))
		values = append(values, filter.Value)
	}

	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}

	rows, err = db.Query(query+" ORDER BY id ASC", values...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()
	for rows.Next() {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
			break
		}

		entity := New()
		err = rows.Scan(entity.ID, entity.Surname, entity.OtherNames, entity.Gender, entity.DOB)
		if err != nil {
			return nil, err
		}

		list = append(list, entity)
	}

	return list, nil
}

// Delete deletes a Citizen record from database and sets id to nil
func (entity *Citizen) Delete(ctx context.Context, tx *sql.Tx, autocommit bool) error {
	var (
		err  error
		stmt *sql.Stmt
	)
	id := *entity.ID

	if tx == nil {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
			tx, err = db.Begin()
			if err != nil {
				return err
			}
		}
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		stmt, err = tx.Prepare("DELETE FROM  WHERE id = $1")
		if err != nil {
			return err
		}
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		_, err = stmt.Exec(id)
		if err == nil {
			entity.ID = nil
		} else {
			tx.Rollback()
			return err
		}
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		if autocommit {
			err = tx.Commit()
		}
	}

	return nil
}

// Delete deletes many Citizen records from database using filter
func Delete(ctx context.Context, filters []models.ListFilter, tx *sql.Tx, autocommit bool) error {
	var (
		err      error
		stmt     *sql.Stmt
		segments []string
		values   []interface{}
	)

	if tx == nil {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
			tx, err = db.Begin()
			if err != nil {
				return err
			}
		}
	}

	query := "DELETE FROM "

	select {
	case <-ctx.Done():
		tx.Rollback()
		return ctx.Err()
	default:
		break
	}

	for i, filter := range filters {
		segments = append(segments, filter.Field+" "+filter.Operation+" $"+strconv.Itoa(i+1))
		values = append(values, filter.Value)
	}

	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}

	stmt, err = db.Prepare(query)
	if err != nil {
		return err
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		_, err = stmt.Exec(values...)
		if err != nil {
			tx.Rollback()
			return err
		}
	}

	select {
	case <-ctx.Done():
		tx.Rollback()
		return ctx.Err()
	default:
		if autocommit {
			err = tx.Commit()
		}
	}

	return err
}

// Save either inserts or updates a Citizen record based on whether or not id is nil
func (entity *Citizen) Save(ctx context.Context, tx *sql.Tx, autocommit bool) error {
	if entity.ID == nil {
		return entity.Insert(tx, autocommit)
	}
	return entity.Update(tx, autocommit)
}

// Insert performs an SQL insert for Citizen record and update instance with inserted id.
func (entity *Citizen) Insert(ctx context.Context, tx *sql.Tx, autocommit bool) error {
	var (
		id   string
		err  error
		stmt *sql.Stmt
	)

	if tx == nil {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
			tx, err = db.Begin()
			if err != nil {
				return err
			}
		}
	}

	select {
	case <-ctx.Done():
		tx.Rollback()
		return ctx.Err()
	default:
		break
	}

	stmt, err = tx.Prepare("INSERT INTO  (id, surname, othernames, gender, dob) VALUES ($0, $1, $1, $1, $1)")
	if err != nil {
		return err
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		break
	}

	idUUID, err := uuid.NewV4()

	if err == nil {
		id = idUUID.String()
	} else {
		tx.Rollback()
		return err
	}
	*entity.ID = id

	select {
	case <-ctx.Done():
		tx.Rollback()
		return ctx.Err()
	default:
		break
	}

	_, err = stmt.Exec(*entity.ID, *entity.Surname, *entity.OtherNames, *entity.Gender, *entity.DOB)
	if err != nil {
		tx.Rollback()
		return err
	}

	select {
	case <-ctx.Done():
		tx.Rollback()
		return ctx.Err()
	default:
		if autocommit {
			err = tx.Commit()
		}
	}

	return nil
}

// Update Will execute an SQLUpdate Statement for Citizen in the database. Prefer using Save instead of Update directly.
func (entity *Citizen) Update(ctx context.Context, tx *sql.Tx, autocommit bool) error {
	var (
		err  error
		stmt *sql.Stmt
	)

	if tx == nil {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
			tx, err = db.Begin()
			if err != nil {
				return err
			}
		}
	}

	select {
	case <-ctx.Done():
		tx.Rollback()
		return ctx.Err()
	default:
		break
	}

	stmt, err = tx.Prepare("UPDATE  SET surname = $1, othernames = $2, gender = $3, dob = $4 WHERE id = $1")
	if err != nil {
		return err
	}

	select {
	case <-ctx.Done():
		tx.Rollback()
		return ctx.Err()
	default:
		break
	}
	_, err = stmt.Exec(*entity.Surname, *entity.OtherNames, *entity.Gender, *entity.DOB)
	if err != nil {
		tx.Rollback()
		return err
	}

	select {
	case <-ctx.Done():
		tx.Rollback()
		return ctx.Err()
	default:
		if autocommit {
			err = tx.Commit()
		}
	}

	return err
}

// Merge performs an SQL merge for Citizen record.
func (entity *Citizen) Merge(ctx context.Context, tx *sql.Tx, autocommit bool) error {
	var (
		err  error
		stmt *sql.Stmt
	)

	if tx == nil {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
			tx, err = db.Begin()
			if err != nil {
				return err
			}
		}
	}

	if entity.ID == nil {
		return entity.Insert(ctx, tx, autocommit)
	}

	stmt, err = tx.Prepare(`INSERT INTO  (id, surname, othernames, gender, dob) VALUES ($0, $0, $1, $2, $3) 
	ON CONFLICT (id) DO UPDATE SET surname = $0, othernames = $1, gender = $2, dob = $3`)
	if err != nil {
		return err
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		break
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		break
	}
	_, err = stmt.Exec(*entity.ID, *entity.Surname, *entity.OtherNames, *entity.Gender, *entity.DOB)
	if err != nil {
		tx.Rollback()
		return err
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		if autocommit {
			err = tx.Commit()
		}
	}

	return err
}
